/* 
 * File:   instructions.h
 * Author: Jason Langenauer
 *
 * Created on 30 November 2009, 8:31 PM
 */

#ifndef _INSTRUCTIONS_H
#define	_INSTRUCTIONS_H

typedef unsigned long dword; // 32 bits

typedef dword opcode; // Encoding of actual opcodes to be generated
typedef dword operand; // Encoding of the operand types

// Operand Bitfield
// Byte 4 | Byte 3 | Byte 2 | Byte 1
// Reg Val   Size     Type  | Not Used

#define BITS8 0x00010000
#define BITS16 0x00020000
#define BITS32 0x00040000
#define BITS48 0x00100000
#define BITS64 0x00200000

#define NOT_USED 0x00000000
#define NO_OPERANDS {NOT_USED,NOT_USED,NOT_USED}

// Immediate Operands
#define IMM 0x00000200
#define IMM8  (IMM | BITS8)
#define IMM16 (IMM | BITS16)
#define IMM32 (IMM | BITS32)

// Register / Memory operands
#define RM 0x00000400
#define RM8  (RM | BITS8)
#define RM16 (RM | BITS16)
#define RM32 (RM | BITS32)

// Register operands
#define REGISTER 0x00000800
#define R8  (REGISTER | BITS8 ) // AL,AH,BL,BH,CL,CH,DL,DH,SPL,BPL,SIL,DIL
#define R16 (REGISTER | BITS16) // AX,BX,CX,DX,SP,BP,SI,DI
#define R32 (REGISTER | BITS32) // EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI

// Specific register operands - match to the specific register
#define GEN_REG 0x01000000
#define SEG_REG 0x02000000
#define FP_REG  0x04000000
#define MMX_REG 0x08000000

#define AL (R8 | GEN_REG | 0x00)
#define CL (R8 | GEN_REG | 0x01)
#define DL (R8 | GEN_REG | 0x02)
#define BL (R8 | GEN_REG | 0x03)
#define AH (R8 | GEN_REG | 0x04)
#define CH (R8 | GEN_REG | 0x05)
#define DH (R8 | GEN_REG | 0x06)
#define BH (R8 | GEN_REG | 0x07)

#define AX (R16 | GEN_REG | 0x00)
#define CX (R16 | GEN_REG | 0x01)
#define DX (R16 | GEN_REG | 0x02)
#define BX (R16 | GEN_REG | 0x03)
#define SP (R16 | GEN_REG | 0x04)
#define BP (R16 | GEN_REG | 0x05)
#define SI (R16 | GEN_REG | 0x06)
#define DI (R16 | GEN_REG | 0x07)

#define EAX (R32 | GEN_REG | 0x00)
#define ECX (R32 | GEN_REG | 0x01)
#define EDX (R32 | GEN_REG | 0x02)
#define EBX (R32 | GEN_REG | 0x03)
#define ESP (R32 | GEN_REG | 0x04)
#define EBP (R32 | GEN_REG | 0x05)
#define ESI (R32 | GEN_REG | 0x06)
#define EDI (R32 | GEN_REG | 0x07) 

// NB - will need to test for GEN_REG, not just REGISTER for operand matching
#define ES  (R16 | SEG_REG | 0x00)
#define CS  (R16 | SEG_REG | 0x01)
#define SS  (R16 | SEG_REG | 0x02)
#define DS  (R16 | SEG_REG | 0x03)
#define FS  (R16 | SEG_REG | 0x04)
#define GS  (R16 | SEG_REG | 0x05)

// Memory operands - e.g. [AL], [EAX+0x01], [2*EBX + 0x00FF3322]
#define MEMORY 0x00001000
#define M8  (MEMORY | BITS8)
#define M16 (MEMORY | BITS16)
#define M1616 (MEMORY | BITS16) // Memory reference to a 16:
#define M32 (MEMORY | BITS32)
#define M1632 (MEMORY | BITS32) // Memory Reference to a 16:32 ptr

// Relative Offset operands
#define RELATIVE 0x00002000
#define REL8  (RELATIVE | BITS8)
#define REL16 (RELATIVE | BITS16)
#define REL32 (RELATIVE | BITS32)

// PTR operands for far calls - e.g. IMM16:IMM32 is a 32-bit offset into
// the segment which IMM16 is the selector
#define PTR 0x00004000
#define PTR1616 (PTR | BITS16)
#define PTR1632 (PTR | BITS32)

// Opcode Definition bitmask
//   Byte 4  |  Byte 3  |  Byte 2  |  Byte 1  |
//   Reg     |  # Bits  |  Type    |  Value   |

// Machine code directly encoded into the opcode
#define CON( opcode ) ((opcode) & 0x000001FF)

// Opcode extensions are defined as /8 in the Intel documentation. This means
// that the reg field of the ModR/M byte is used as an opcode extension
#define OPCODE_EX_BIT 0x00000200
#define OPCODE_EX(d) ((0x00000007 & (d)) | OPCODE_EX_BIT)

// The ModR/M byte of the instruction contains both a r/m code and an register
// code. Denoted by /r in the Intel documentation.
#define MOD_RM 0x00000400

// Immediate opcodes - represented by IB, IW, ID, IO, and are a sequence of
// bytes written directly into the instruction stream
#define IMMEDIATE_OPCODE 0x00000800
#define IB (IMMEDIATE_OPCODE | BITS8)
#define IW (IMMEDIATE_OPCODE | BITS16)
#define ID (IMMEDIATE_OPCODE | BITS32)

// Address-mode Prefixes - denotes when address-mode override prefixes need
// to be used
#define OPSIZE_MODE  0x00001000
#define ADDSIZE_MODE 0x00002000
#define O16 (OPSIZE_MODE | BITS16)  // Use 0x66 Prefix in 32-bit mode
#define O32 (OPSIZE_MODE | BITS32)  // USe 0x66 Prefix in 16-bit mode
#define A16 (ADDSIZE_MODE | BITS16)
#define A32 (ADDSIZE_MODE | BITS32)

// Register encoded opcode - Opcode generated by adding a register code
// to the base opcode given - denoted by +rb, +rw, +rw, +ro in the Intel
// Documentation. Because the offset is consistent regardless of the size
// of the register (e.g. AL,
#define REGISTER_CODE 0x00002000
#define REG_B(op) ((REGISTER_CODE | BITS8) | (0x000000FF & (op)))
#define REG_W(op) ((REGISTER_CODE | BITS16) | (0x000000FF & (op)))
#define REG_D(op) ((REGISTER_CODE | BITS32) | (0x000000FF & (op)))

// Code offset opcodes - 
#define CODE_OFFSET 0x00004000
#define CB  (CODE_OFFSET | BITS8)
#define CW  (CODE_OFFSET | BITS16)
#define CD  (CODE_OFFSET | BITS32)
#define CP  (CODE_OFFSET | BITS48)

typedef struct {
    const char mnemonic[10];
    operand operands[3];
    opcode prefix;
    opcode opcodes[4];
} InstructionPrototype;

InstructionPrototype x86_instructions[] = {
{"AAA",     {NOT_USED,NOT_USED,NOT_USED}, 0,   {CON(0x37), 0, 0, 0}},                   // ASCII Adjust After Addition
{"AAD",     {NOT_USED,NOT_USED,NOT_USED}, 0,   {CON(0xD5), CON(0x0A), 0, 0}},           // ASCII Adjust AX Before Division
{"AAM",     {NOT_USED,NOT_USED,NOT_USED}, 0,   {CON(0xD4), CON(0x0A), 0, 0}},           // ASCII Adjust AX After Multiply
{"AAS",     {NOT_USED,NOT_USED,NOT_USED}, 0,   {CON(0x3F), 0, 0, 0}},                   // ASCII Adjust AL After Subtraction

{"ADC",     {RM8,     IMM8,    NOT_USED}, 0,   {CON(0x80), OPCODE_EX(2), IB, 0}},       // Add IMM8 to RM8 with carry
{"ADC",     {RM16,    IMM16,   NOT_USED}, O16, {CON(0x81), OPCODE_EX(2), IW, 0}},       // Add IMM16 to RM16 with carry
{"ADC",     {RM32,    IMM32,   NOT_USED}, O32, {CON(0x81), OPCODE_EX(2), ID, 0}},       // Add IMM32 to RM32 with carry
{"ADC",     {RM16,    IMM8,    NOT_USED}, O16, {CON(0x83), OPCODE_EX(2), IB, 0}},       // Add sign-extended IMM8 to RM16 with carry
{"ADC",     {RM32,    IMM8,    NOT_USED}, O32, {CON(0x83), OPCODE_EX(2), IB, 0}},       // Add sign-extended IMM8 to RM32 with carry
{"ADC",     {RM8,     R8,      NOT_USED}, 0,   {CON(0x10), MOD_RM, 0, 0}},              // Add R8 to RM8 with carry
{"ADC",     {RM16,    R16,     NOT_USED}, O16, {CON(0x11), MOD_RM, 0, 0}},              // Add R16 to RM16 with carry
{"ADC",     {RM32,    R32,     NOT_USED}, O32, {CON(0x11), MOD_RM, 0, 0}},              // Add R32 to RM32 with carry
{"ADC",     {R8,      RM8,     NOT_USED}, 0,   {CON(0x12), MOD_RM, 0, 0}},              // Add RM8 to R8 with carry
{"ADC",     {R16,     RM16,    NOT_USED}, O16, {CON(0x13), MOD_RM, 0, 0}},              // Add RM16 to R16 with carry
{"ADC",     {R32,     RM32,    NOT_USED}, O32, {CON(0x13), MOD_RM, 0, 0}},              // Add RM32 to R32 with carry

{"ADD",     {RM8,     IMM8,    NOT_USED}, 0,   {CON(0x80), OPCODE_EX(0), IB, 0}},       // Add IMM8 to RM8
{"ADD",     {RM16,    IMM16,   NOT_USED}, O16, {CON(0x81), OPCODE_EX(0), IW, 0}},       // Add IMM16 to RM16
{"ADD",     {RM32,    IMM32,   NOT_USED}, O32, {CON(0x81), OPCODE_EX(0), ID, 0}},       // Add IMM32 to RM32
{"ADD",     {RM16,    IMM8,    NOT_USED}, O16, {CON(0x83), OPCODE_EX(0), IB, 0}},       // Add sign-extended IMM8 to RM16
{"ADD",     {RM32,    IMM8,    NOT_USED}, O32, {CON(0x83), OPCODE_EX(0), IB, 0}},       // Add sign-extended IMM8 to RM32
{"ADD",     {RM8,     R8 ,     NOT_USED}, 0,   {CON(0x00), MOD_RM, 0, 0}},              // Add R8 to RM8
{"ADD",     {RM16,    R16,     NOT_USED}, O16, {CON(0x01), MOD_RM, 0, 0}},              // Add R16 to RM16
{"ADD",     {RM32,    R32,     NOT_USED}, O32, {CON(0x01), MOD_RM, 0, 0}},              // Add R32 to RM32
{"ADD",     {R8,      RM8,     NOT_USED}, 0,   {CON(0x02), MOD_RM, 0, 0}},              // Add RM8 to R8
{"ADD",     {R16,     RM16,    NOT_USED}, O16, {CON(0x03), MOD_RM, 0, 0}},              // Add RM16 to R16
{"ADD",     {R32,     RM32,    NOT_USED}, O32, {CON(0x03), MOD_RM, 0, 0}},              // Add RM32 to R32

{"AND",     {RM8,     IMM8,    NOT_USED}, 0,   {CON(0x80), OPCODE_EX(4), IB, 0}},       // RM8 AND IMM8
{"AND",     {RM16,    IMM16,   NOT_USED}, O16, {CON(0x81), OPCODE_EX(4), IW, 0}},       // RM16 AND IMM16
{"AND",     {RM32,    IMM32,   NOT_USED}, O32, {CON(0x81), OPCODE_EX(4), ID, 0}},       // RM32 AND IMM32
{"AND",     {RM16,    IMM8,    NOT_USED}, O16, {CON(0x83), OPCODE_EX(4), IB, 0}},       // RM16 AND IMM8
{"AND",     {RM32,    IMM8,    NOT_USED}, O32, {CON(0x83), OPCODE_EX(4), IB, 0}},       // RM32 AND IMM8
{"AND",     {RM8,     R8,      NOT_USED}, 0,   {CON(0x20), MOD_RM, 0, 0}},              // RM8 AND R8
{"AND",     {RM16,    R16,     NOT_USED}, O16, {CON(0x21), MOD_RM, 0, 0}},              // RM16 AND R16
{"AND",     {RM32,    R32,     NOT_USED}, O32, {CON(0x21), MOD_RM, 0, 0}},              // RM32 AND R32
{"AND",     {R8,      RM8,     NOT_USED}, 0,   {CON(0x22), MOD_RM, 0, 0}},              // R8 AND RM8
{"AND",     {R16,     RM16,    NOT_USED}, O16, {CON(0x23), MOD_RM, 0, 0}},              // R16 AND RM16
{"AND",     {R32,     RM32,    NOT_USED}, O32, {CON(0x23), MOD_RM, 0, 0}},              // R32 AND RM32

{"ARPL",    {RM16,    R16,     NOT_USED}, 0,  {CON(0x63), MOD_RM, 0, 0}},              // Adjust RPL Field of Segment Selector

{"BOUND",   {R16,     M16,     NOT_USED}, O16, {CON(0x62), MOD_RM, 0, 0}},              // Check R16 (array index) within bound M16&16
{"BOUND",   {R32,     M32,     NOT_USED}, O32, {CON(0x62), MOD_RM, 0, 0}},              // Check R32 (array index) within bound M32&32

{"BSF",     {R16,     RM16,    NOT_USED}, O16, {CON(0x0F), CON(0xBC), MOD_RM, 0}},      // Bit Scan Forward on RM16, result in R16
{"BSF",     {R32,     RM32,    NOT_USED}, O32, {CON(0x0F), CON(0xBC), MOD_RM, 0}},      // Bit Scan Forward on RM32, result in R32

{"BSR",     {R16,     RM16,    NOT_USED}, O16, {CON(0x0F), CON(0xBD), MOD_RM, 0}},      // Bit Scan Reverse on RM16, result in R16
{"BSR",     {R32,     RM32,    NOT_USED}, O32, {CON(0x0F), CON(0XBD), MOD_RM, 0}},      // Bit Scan Reverse on RM32, result in R32

{"BSWAP",   {R32,     NOT_USED,NOT_USED}, O32, {CON(0x0F), REG_D(0xC8), 0, 0}},         // Swap byte order in R32

{"BT",      {RM16,    R16,     NOT_USED}, O16, {CON(0x0F), CON(0xA3), MOD_RM, 0}},      // Bit test RM16 at R16, store in CF
{"BT",      {RM32,    R32,     NOT_USED}, O32, {CON(0x0F), CON(0xA3), MOD_RM, 0}},      // Bit test RM32 at R32, store in CF
{"BT",      {RM16,    IMM8,    NOT_USED}, O16, {CON(0x0F), CON(0xBA), OPCODE_EX(4), IB}},  // Bit test RM16 at IMM8, store in CF
{"BT",      {RM32,    IMM8,    NOT_USED}, O32, {CON(0x0F), CON(0xBA), OPCODE_EX(4), IB}},  // Bit test RM32 at IMM8, store in CF

{"BTC",     {RM16,    R16,     NOT_USED}, O16, {CON(0x0F), CON(0xBB), MOD_RM, 0}},      // Bit Test & Complement RM16 at R16, store in CF
{"BTC",     {RM32,    R32,     NOT_USED}, O32, {CON(0x0F), CON(0xBB), MOD_RM, 0}},      // Bit Test & Complement RM32 at R32, store in CF
{"BTC",     {RM16,    IMM8,    NOT_USED}, O16, {CON(0x0F), CON(0xBA), OPCODE_EX(7), IB}},  // Bit Test & complement RM36 at IMM8, store in CF
{"BTC",     {RM32,    IMM8,    NOT_USED}, O32, {CON(0x0F), CON(0xBA), OPCODE_EX(7), IB}},  // Bit Test & Complement RM32 at IMM8, store in CF

{"BTR",     {RM16,    R16,     NOT_USED}, O16, {CON(0x0F), CON(0xB3), MOD_RM, 0}},      // Bit Test & Reset RM16 at R16, store in CF
{"BTR",     {RM32,    R32,     NOT_USED}, O32, {CON(0x0F), CON(0xB3), MOD_RM, 0}},      // Bit Test & Reset RM32 at R32, store in CF
{"BTR",     {RM16,    IMM8,    NOT_USED}, O16, {CON(0x0F), CON(0xBA), OPCODE_EX(6), IB}},  // Bit Test & Reset RM36 at IMM8, store in CF
{"BTR",     {RM32,    IMM8,    NOT_USED}, O32, {CON(0x0F), CON(0xBA), OPCODE_EX(6), IB}},  // Bit Test & Reset RM32 at IMM8, store in CF

{"BTS",     {RM16,    R16,     NOT_USED}, O16, {CON(0x0F), CON(0xAB), MOD_RM, 0}},      // Bit Test & Set RM16 at R16, store in CF
{"BTS",     {RM32,    R32,     NOT_USED}, O32, {CON(0x0F), CON(0xAB), MOD_RM, 0}},      // Bit Test & Set RM32 at R32, store in CF
{"BTS",     {RM16,    IMM8,    NOT_USED}, O16, {CON(0x0F), CON(0xBA), OPCODE_EX(5), IB}},  // Bit Test & Set RM36 at IMM8, store in CF
{"BTS",     {RM32,    IMM8,    NOT_USED}, O32, {CON(0x0F), CON(0xBA), OPCODE_EX(5), IB}},  // Bit Test & Set RM32 at IMM8, store in CF

{"CALL",    {REL16,   NOT_USED,NOT_USED}, O16, {CON(0xE8), CW, 0, 0}},                  // Near call, relative displacement REL16
{"CALL",    {REL32,   NOT_USED,NOT_USED}, O32, {CON(0xE8), CD, 0, 0}},                  // Near call, relative displacement REL32   
{"CALL",    {RM16,    NOT_USED,NOT_USED}, O16, {CON(0xFF), OPCODE_EX(2), 0, 0}},        // Near call, absolute address in RM16
{"CALL",    {RM32,    NOT_USED,NOT_USED}, O32, {CON(0xFF), OPCODE_EX(2), 0, 0}},        // Near call, absolute address in RM32
{"CALL",    {PTR1616, NOT_USED,NOT_USED}, O16, {CON(0x9A), CD, 0}},                     // Far call, absolute address PTR16:16
{"CALL",    {PTR1632, NOT_USED,NOT_USED}, O32, {CON(0x9A), CP, 0}},                     // Far call, absolute address PTR16:32
{"CALL FAR",{M1616, NOT_USED,NOT_USED}, O16, {CON(0xFF), OPCODE_EX(3), 0, 0}},        // Far call, absolute address in M1616
{"CALL FAR",{M1632, NOT_USED,NOT_USED}, O32, {CON(0xFF), OPCODE_EX(3), 0, 0}},        // Far call, absolute address in M1632

{"CBW",     NO_OPERANDS,                  O16, {CON(0x98), 0, 0, 0}},                   // Extend AL into AX by repeating sign bit
{"CWD",     NO_OPERANDS,                  O16, {CON(0x99), 0, 0, 0}},                   // Extend AX into DX:AX by repeating sign bit
{"CDW",     NO_OPERANDS,                  O32, {CON(0x99), 0, 0, 0}},                   // Extend EAX into EDX:EAX by repeating sign bit
{"CWDE",    NO_OPERANDS,                  O32, {CON(0x98), 0, 0, 0}},                   // Extend AX into EAX by repeating sign bit

{"CLC",     NO_OPERANDS,                  0,   {CON(0xF8), 0, 0, 0}},                   // Clear the Carry flag
{"CLD",     NO_OPERANDS,                  0,   {CON(0xFC), 0, 0, 0}},                   // Clear the Direction flag
{"CLI",     NO_OPERANDS,                  0,   {CON(0xFA), 0, 0, 0}},                   // Clear the Interrupt flag
{"CLTS",    NO_OPERANDS,                  0,   {CON(0x0F), CON(0x06), 0, 0}},           // Clear the Task Switch flag

{"CMC",     NO_OPERANDS,                  0,   {CON(0xF5), 0, 0, 0}},                   // Clear the Carry flag

{"CMP",     {RM8,     IMM8,    NOT_USED}, 0,   {CON(0x80), OPCODE_EX(7), IB, 0}},       // Compare IMM8 with RM8
{"CMP",     {RM16,    IMM16,   NOT_USED}, O16, {CON(0x81), OPCODE_EX(7), IW, 0}},       // Compare IMM16 with RM16
{"CMP",     {RM32,    IMM32,   NOT_USED}, O32, {CON(0x81), OPCODE_EX(7), ID, 0}},       // Compare IMM32 with RM32
{"CMP",     {RM16,    IMM8,    NOT_USED}, O16, {CON(0x83), OPCODE_EX(7), IB, 0}},       // Compare IMM8 with RM16
{"CMP",     {RM8,     R8,      NOT_USED}, 0,   {CON(0x38), MOD_RM, 0, 0}},              // Compare R8 with RM8
{"CMP",     {RM16,    R16,     NOT_USED}, O16, {CON(0x39), MOD_RM, 0, 0}},              // Compare R16 with RM16
{"CMP",     {RM32,    R32,     NOT_USED}, O32, {CON(0x39), MOD_RM, 0, 0}},              // Compare R32 with RM32
{"CMP",     {R8,      RM8,     NOT_USED}, 0,   {CON(0x3A), MOD_RM, 0, 0}},              // Compare RM8 with R8
{"CMP",     {R16,     RM16,    NOT_USED}, O16, {CON(0x3B), MOD_RM, 0, 0}},              // Compare RM16 with R16
{"CMP",     {R32,     RM32,    NOT_USED}, O32, {CON(0x3B), MOD_RM, 0, 0}},              // Compare RM32 with R3  2

{"CMPSB",   NO_OPERANDS,                  0,   {CON(0xA6), 0, 0, 0}},                   // Compare Byte at [DS:(E)SI] with [ES:(E)DI] and increment
{"CMPSW",   NO_OPERANDS,                  O16, {CON(0xA7), 0, 0, 0}},                   // Compare Word at [DS:(E)SI] with [ES:(E)DI] and increment
{"CMPSD",   NO_OPERANDS,                  O32, {CON(0xA7), 0, 0, 0}},                   // Compare Dword at [DS:(E)SI] with [ES:(E)DI] and increment

{"DAA",     NO_OPERANDS,                  0,   {CON(0x27), 0, 0, 0}},                   // Decimal Adjust AL after addition
{"DAS",     NO_OPERANDS,                  0,   {CON(0x2F), 0, 0, 0}},                   // Decimal Adjust AL after subtraction

{"DEC",     {RM8,     NOT_USED,NOT_USED}, 0,   {CON(0xFE), OPCODE_EX(1), 0, 0}},        // Decrement RM8 by 1
{"DEC",     {RM16,    NOT_USED,NOT_USED}, O16, {CON(0xFF), OPCODE_EX(1), 0, 0}},        // Decrement RM16 by 1
{"DEC",     {RM32,    NOT_USED,NOT_USED}, O32, {CON(0xFF), OPCODE_EX(1), 0, 0}},        // Decrement RM32 by 1
{"DEC",     {R16,     NOT_USED,NOT_USED}, O16, {REG_W(0x48), 0, 0, 0}},                 // Decrement RM16 by 1
{"DEC",     {R32,     NOT_USED,NOT_USED}, O32, {REG_D(0x48), 0, 0, 0}},                 // Decrement RM32 by 1

{"DIV",     {RM8,     NOT_USED,NOT_USED}, 0,   {CON(0xF6), OPCODE_EX(6), 0, 0}},        // Unsigned integer divide AX by RM8 
{"DIV",     {RM16,    NOT_USED,NOT_USED}, O16, {CON(0xF7), OPCODE_EX(6), 0, 0}},        // Unsigned integer divide DX:AX by RM16
{"DIV",     {RM32,    NOT_USED,NOT_USED}, O32, {CON(0xF7), OPCODE_EX(6), 0, 0}},        // Unsigned integer divide EDX:EAX by RM32

{"ENTER",   {IMM16,   IMM8,    NOT_USED}, 0,   {CON(0xC8), IW, IB, 0}},                 // Create a stack frame

{"HLT",     NO_OPERANDS,                  0,   {CON(0xF4), 0, 0, 0}},                   // Halt the processor

{"IDIV",    {RM8,     NOT_USED,NOT_USED}, 0,   {CON(0xF6), OPCODE_EX(7), 0, 0}},        // Signed integer divide AX by RM8
{"IDIV",    {RM16,    NOT_USED,NOT_USED}, O16, {CON(0xF7), OPCODE_EX(7), 0, 0}},        // Signed integer divide DX:AX by RM16
{"IDIV",    {RM32,    NOT_USED,NOT_USED}, O32, {CON(0xF7), OPCODE_EX(7), 0, 0}},        // Signed integer divide EDX:EAX by RM32

{"IMUL",    {RM8,     NOT_USED,NOT_USED}, 0,   {CON(0xF6), OPCODE_EX(5), 0, 0}},        // Signed multiply AL by RM8, put in AX
{"IMUL",    {RM16,    NOT_USED,NOT_USED}, O16, {CON(0xF7), OPCODE_EX(5), 0, 0}},        // Signed multiply AX by RM16, put in DX:AX
{"IMUL",    {RM32,    NOT_USED,NOT_USED}, O32, {CON(0xF7), OPCODE_EX(5), 0, 0}},        // Signed multiply EAX by RM32, put in EDX:EAX
{"IMUL",    {R16,     RM16,    NOT_USED}, O16, {CON(0x0F), CON(0xAF), MOD_RM, 0}},      // Signed multiply RM16 by R16, put in R16
{"IMUL",    {R32,     RM32,    NOT_USED}, O32, {CON(0x0F), CON(0xAF), MOD_RM, 0}},      // Signed multiply RM32 by R32, put in R32

/* Two operand immedaiate forms of IMUL ignored so we don't have to implement the logic
to use the operand provided for both the register and rm parts of the Mod R/M byte. Use
the three operand form if required - e.g. IMUL EAX, $8 becomes IMUL EAX, EAX, $8
{"IMUL",    {R16,    IMM8,     NOT_USED}, O16, {CON(0x6B), MOD_RM, IB, 0}},            // Signed multiply R16 by IMM8, put in R16
{"IMUL",    {R16,    IMM16,    NOT_USED}, O16, {CON(0x69), MOD_RM, IW, 0}},            // Signed multiply R16 by IMM16, put in R16
{"IMUL",    {R32,    IMM8,     NOT_USED}, O32, {CON(0x6B), MOD_RM, IB, 0}},            // Signed multiply R32 by IMM8, put in R32
{"IMUL",    {R32,    IMM16,    NOT_USED}, O32, {CON(0x69), MOD_RM, IW, 0}},            // Signed multiply R32 by IMM16, put in R32
*/

{"IMUL",    {R16,    RM16,     IMM8    }, O16, {CON(0x6B), MOD_RM, IB, 0}},            // Signed multiply RM16 by IMM8, put in R16
{"IMUL",    {R16,    RM16,     IMM16   }, O16, {CON(0x69), MOD_RM, IW, 0}},            // Signed multiply RM16 by IMM16, put in R16
{"IMUL",    {R32,    RM32,     IMM8    }, O32, {CON(0x6B), MOD_RM, IB, 0}},            // Signed multiply RM32 by IMM8, put in R32
{"IMUL",    {R32,    RM32,     IMM16   }, O32, {CON(0x69), MOD_RM, IW, 0}},            // Signed multiply RM32 by IMM16, put in R32

{"IN",      {AL,     IMM8,     NOT_USED}, 0,   {CON(0xE4), IB, 0, 0}},                 // Read a byte from IO port IMM8
{"IN",      {AX,     IMM8,     NOT_USED}, O16, {CON(0xE5), IB, 0, 0}},                 // Read a word from IO port IMM8
{"IN",      {EAX,    IMM8,     NOT_USED}, O32, {CON(0xE5), IB, 0, 0}},                 // Read a dword from IO port IMM8
{"IN",      {AL,     DX,       NOT_USED}, 0,   {CON(0xEC), 0, 0, 0}},                  // Read a byte from IO port DX
{"IN",      {AX,     DX,       NOT_USED}, O16, {CON(0xED), 0, 0, 0}},                  // Read a word from IO port DX
{"IN",      {EAX,    DX,       NOT_USED}, O32, {CON(0xED), 0, 0, 0}},                  // Read a dwod from IO port DX

{"INC",     {R16,    NOT_USED, NOT_USED}, O16, {REG_W(0x40), 0, 0, 0}},                // Increment R16
{"INC",     {R32,    NOT_USED, NOT_USED}, O32, {REG_D(0x40), 0, 0, 0}},                // Increment R32
{"INC",     {RM8,    NOT_USED, NOT_USED}, 0,   {CON(0xFE), OPCODE_EX(0), 0, 0}},       // Increment RM8
{"INC",     {RM16,   NOT_USED, NOT_USED}, O16, {CON(0xFF), OPCODE_EX(0), 0, 0}},       // Increment RM16
{"INC",     {RM32,   NOT_USED, NOT_USED}, O32, {CON(0xFF), OPCODE_EX(0), 0, 0}},       // Increment RM32 

{"INSB",    NO_OPERANDS,                  0,   {CON(0x6C), 0, 0, 0}},                  // Read a byte from IO port DX into ES:(E)DI
{"INSW",    NO_OPERANDS,                  O16, {CON(0x6D), 0, 0, 0}},                  // Read a word from IO port DX into ES:(E)DI
{"INSD",    NO_OPERANDS,                  O32, {CON(0x6D), 0, 0, 0}},                  // Read a dword from IO port DX into ES:(E)DI

{"INT",     {IMM8,   NOT_USED, NOT_USED}, 0,   {CON(0xCD), IB, 0, 0}},                 // Software interrupt IMM8
{"INT3",    NO_OPERANDS,                  0,   {CON(0xCC), 0, 0, 0}},                  // Interrupt 3 - breakpoint
{"INTO",    NO_OPERANDS,                  0,   {CON(0xCE), 0, 0, 0}},                  // Interrupt 4 if OF set

/*
{"INVTLB",  {MEM,    NOT_USED, NOT_USED}, 0,   {CON(0x0F), CON(0x01), OPCODE_EX(7), 0}}, // Invalidate TLB buffer
*/

{"IRET",    NO_OPERANDS,                  0,   {CON(0xCF), 0, 0, 0}},                  // Return from interrupt
{"IRETW",   NO_OPERANDS,                  O16, {CON(0xCF), 0, 0, 0}},                  // Return from interrupt
{"IRETD",   NO_OPERANDS,                  O32, {CON(0xCF), 0, 0, 0}},                  // Return from interrupt

{"JA",      {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x77), CB, 0, 0}},                 // Jump short if above
{"JA",      {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x87), CW, 0}},         // Jump near if above
{"JA",      {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x87), CD, 0}},         // Jump near if above

{"JAE",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x73), CB, 0, 0}},                 // Jump short if above or equal
{"JAE",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x83), CW, 0}},         // Jump near if above or equal
{"JAE",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x83), CD, 0}},         // Jump near if above or equal

{"JB",      {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x72), CB, 0, 0}},                 // Jump short if below
{"JB",      {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x82), CW, 0}},         // Jump near if below
{"JB",      {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x82), CD, 0}},         // Jump near if below

{"JBE",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x76), CB, 0, 0}},                 // Jump short if below or equal
{"JBE",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x86), CW, 0}},         // Jump near if below or equal
{"JBE",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x86), CD, 0}},         // Jump near if below or equal

{"JC",      {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x72), CB, 0, 0}},                 // Jump short if carry
{"JC",      {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x82), CW, 0}},         // Jump near if carry
{"JC",      {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x82), CD, 0}},         // Jump near if carry

{"JE",      {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x74), CB, 0, 0}},                 // Jump short if equal
{"JE",      {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x84), CW, 0}},         // Jump near if equal
{"JE",      {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x84), CD, 0}},         // Jump near if equal

{"JG",      {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x7F), CB, 0, 0}},                 // Jump short if greater
{"JG",      {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x8F), CW, 0}},         // Jump near if greater
{"JG",      {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x8F), CD, 0}},         // Jump near if greater

{"JGE",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x7D), CB, 0, 0}},                 // Jump short if greater or equal
{"JGE",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x8D), CW, 0}},         // Jump near if greater or equal
{"JGE",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x8D), CD, 0}},         // Jump near if greater or equal

{"JL",      {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x7C), CB, 0, 0}},                 // Jump short if less
{"JL",      {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x8C), CW, 0}},         // Jump near if less
{"JL",      {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x8C), CD, 0}},         // Jump near if less

{"JLE",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x7E), CB, 0, 0}},                 // Jump short if less or equal
{"JLE",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x8E), CW, 0}},         // Jump near if less or equal
{"JLE",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x8E), CD, 0}},         // Jump near if less or equal

{"JNA",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x76), CB, 0, 0}},                 // Jump short if not above
{"JNA",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x86), CW, 0}},         // Jump near if not above
{"JNA",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x86), CD, 0}},         // Jump near if not above

{"JNAE",    {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x72), CB, 0, 0}},                 // Jump short if not above or equal
{"JNAE",    {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x82), CW, 0}},         // Jump near if not above or equal
{"JNAE",    {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x82), CD, 0}},         // Jump near if not above or equal

{"JNB",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x73), CB, 0, 0}},                 // Jump short if not below
{"JNB",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x83), CW, 0}},         // Jump near if not below
{"JNB",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x83), CD, 0}},         // Jump near if not below

{"JNBE",    {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x77), CB, 0, 0}},                 // Jump short if not below or equal
{"JNBE",    {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x87), CW, 0}},         // Jump near if not below or equal
{"JNBE",    {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x87), CD, 0}},         // Jump near if not below or equal

{"JNC",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x73), CB, 0, 0}},                 // Jump short if not carry
{"JNC",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x83), CW, 0}},         // Jump near if not carry
{"JNC",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x83), CD, 0}},         // Jump near if not carry

{"JNE",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x75), CB, 0, 0}},                 // Jump short if not equal
{"JNE",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x85), CW, 0}},         // Jump near if not equal
{"JNE",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x85), CD, 0}},         // Jump near if not equal

{"JNG",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x7E), CB, 0, 0}},                 // Jump short if not greater
{"JNG",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x8E), CW, 0}},         // Jump near if not greater
{"JNG",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x8E), CD, 0}},         // Jump near if not greater

{"JNGE",    {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x7C), CB, 0, 0}},                 // Jump short if not greater or equal
{"JNGE",    {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x8C), CW, 0}},         // Jump near if not greater or equal
{"JNGE",    {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x8C), CD, 0}},         // Jump near if not greater or equal

{"JNL",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x7D), CB, 0, 0}},                 // Jump short if not less
{"JNL",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x8D), CW, 0}},         // Jump near if not less
{"JNL",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x8D), CD, 0}},         // Jump near if not less

{"JNLE",    {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x7F), CB, 0, 0}},                 // Jump short if not less or equal
{"JNLE",    {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x8F), CW, 0}},         // Jump near if not less or equal
{"JNLE",    {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x8F), CD, 0}},         // Jump near if not less or equal

{"JNO",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x71), CB, 0, 0}},                 // Jump short if not overflow
{"JNO",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x81), CW, 0}},         // Jump near if not overflow
{"JNO",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x81), CD, 0}},         // Jump near if not overflow

{"JNP",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x7B), CB, 0, 0}},                 // Jump short if not parity
{"JNP",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x8B), CW, 0}},         // Jump near if not parity
{"JNP",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x8B), CD, 0}},         // Jump near if not parity

{"JNS",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x79), CB, 0, 0}},                 // Jump short if not sign
{"JNS",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x89), CW, 0}},         // Jump near if not sign
{"JNS",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x89), CD, 0}},         // Jump near if not sign

{"JNZ",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x75), CB, 0, 0}},                 // Jump short if not zero
{"JNZ",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x85), CW, 0}},         // Jump near if not zero
{"JNZ",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x85), CD, 0}},         // Jump near if not zero

{"JO",      {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x70), CB, 0, 0}},                 // Jump short if overflow
{"JO",      {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x80), CW, 0}},         // Jump near if overflow
{"JO",      {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x80), CD, 0}},         // Jump near if overflow

{"JP",      {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x7A), CB, 0, 0}},                 // Jump short if parity
{"JP",      {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x8A), CW, 0}},         // Jump near if parity
{"JP",      {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x8A), CD, 0}},         // Jump near if parity

{"JPE",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x7A), CB, 0, 0}},                 // Jump short if parity even
{"JPE",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x8A), CW, 0}},         // Jump near if parity even
{"JPE",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x8A), CD, 0}},         // Jump near if parity even

{"JPO",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x7B), CB, 0, 0}},                 // Jump short if parity odd
{"JPO",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x8B), CW, 0}},         // Jump near if parity odd
{"JPO",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x8B), CD, 0}},         // Jump near if parity odd

{"JS",      {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x78), CB, 0, 0}},                 // Jump short if sign
{"JS",      {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x88), CW, 0}},         // Jump near if sign
{"JS",      {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x88), CD, 0}},         // Jump near if sign

{"JZ",      {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0x74), CB, 0, 0}},                 // Jump short if sign
{"JZ",      {REL16,  NOT_USED, NOT_USED}, O16, {CON(0x0F), CON(0x84), CW, 0}},         // Jump near if sign
{"JZ",      {REL32,  NOT_USED, NOT_USED}, O32, {CON(0x0F), CON(0x84), CD, 0}},         // Jump near if sign 

{"JMP",     {REL8,   NOT_USED, NOT_USED}, 0,   {CON(0xEB), CB, 0, 0}},                 // Jump short
{"JMP",     {REL16,  NOT_USED, NOT_USED}, O16, {CON(0xE9), CW, 0, 0}},                 // Jump near
{"JMP",     {REL32,  NOT_USED, NOT_USED}, O32, {CON(0xE9), CD, 0, 0}},                 // Jump near
{"JMP",     {RM16,   NOT_USED, NOT_USED}, O16, {CON(0xFF), OPCODE_EX(4), 0, 0}},       // Jump near
{"JMP",     {RM32,   NOT_USED, NOT_USED}, O32, {CON(0xFF), OPCODE_EX(4), 0, 0}},       // Jump near
{"JMP FAR", {PTR1616,NOT_USED, NOT_USED}, O16, {CON(0xEA), CD, 0, 0}},                 // Jump far, absolute address
{"JMP FAR", {PTR1632,NOT_USED, NOT_USED}, O32, {CON(0xEA), CP, 0, 0}},                 // Jump far, absolute address
{"JMP FAR", {M1616,  NOT_USED, NOT_USED}, O16, {CON(0xFF), OPCODE_EX(5), 0, 0}},       // Jump far, indirect address
{"JMP FAR", {M1632,  NOT_USED, NOT_USED}, O32, {CON(0xFF), OPCODE_EX(5), 0, 0}},       // Jump far, indirect address

{"LAHF",    NO_OPERANDS,                  0,   {CON(0x9F), 0, 0, 0}},                  // Load Flags into AH

{"LAR",     {R16,    RM16,     NOT_USED}, O16, {CON(0x0F), CON(0x02), MOD_RM, 0}},     // Load Access Rights byte for RM16 segment
{"LAR",     {R32,    RM32,     NOT_USED}, O32, {CON(0x0F), CON(0x02), MOD_RM, 0}},     // Load Access Rights byte for RM32 segment

{"LDS",     {R16,    M1616,    NOT_USED}, O16, {CON(0xC5), MOD_RM, 0, 0}},             // Load 16:16 far pointer into DS:R16
{"LDS",     {R32,    M1632,    NOT_USED}, O32, {CON(0xC5), MOD_RM, 0, 0}},             // Load 16:32 far pointer into DS:R32
{"LES",     {R16,    M1616,    NOT_USED}, O16, {CON(0xC4), MOD_RM, 0, 0}},             // Load 16:16 far pointer into ES:R16
{"LES",     {R32,    M1632,    NOT_USED}, O32, {CON(0xC4), MOD_RM, 0, 0}},             // Load 16:32 far pointer into ES:R32
{"LFS",     {R16,    M1616,    NOT_USED}, O16, {CON(0x0F), CON(0xB4), MOD_RM, 0}},     // Load 16:16 far pointer into FS:R16
{"LFS",     {R32,    M1632,    NOT_USED}, O32, {CON(0x0F), CON(0xB4), MOD_RM, 0}},     // Load 16:32 far pointer into FS:R32
{"LGS",     {R16,    M1616,    NOT_USED}, O16, {CON(0x0F), CON(0xB5), MOD_RM, 0}},     // Load 16:16 far pointer into GS:R16
{"LGS",     {R32,    M1632,    NOT_USED}, O32, {CON(0x0F), CON(0xB5), MOD_RM, 0}},     // Load 16:32 far pointer into GS:R32
{"LSS",     {R16,    M1616,    NOT_USED}, O16, {CON(0x0F), CON(0xB2), MOD_RM, 0}},     // Load 16:16 far pointer into SS:R16
{"LSS",     {R32,    M1632,    NOT_USED}, O32, {CON(0x0F), CON(0xB2), MOD_RM, 0}},     // Load 16:32 far pointer into SS:R32

{"LEA",     {R16,    M16,      NOT_USED}, O16, {CON(0x8D), MOD_RM, 0, 0}},             // Load Effective Address into R16
{"LEA",     {R32,    M32,      NOT_USED}, O16, {CON(0x8D), MOD_RM, 0, 0}},             // Load Effective Address into R32   

{"LEAVE",   NO_OPERANDS,                  0,   {CON(0xC9), 0, 0, 0}},                  // Set (E)SP to (E)BP, then pop (E)BP

// LFENCE ignored for now.

{"LGDT",    {M32,    NOT_USED, NOT_USED}, 0,   {CON(0x0F), CON(0x01), OPCODE_EX(2), 0}}, // Load M16&32 linear address into GDT
{"LIDT",    {M32,    NOT_USED, NOT_USED}, 0,   {CON(0x0F), CON(0x01), OPCODE_EX(3), 0}}, // Load M16&32 linear address into IDT
{"LLDT",    {RM16,   NOT_USED, NOT_USED}, 0,   {CON(0x0F), CON(0x00), OPCODE_EX(2), 0}}, // Load selector RM16 addresses into LDT

// LMSW ignored - 286 only
// LOADALL ignored - 286, 386 only

{"LOCK",    NO_OPERANDS,                  0,   {CON(0xF0), 0, 0, 0}},                  // Execute the next instruction atomically

{"LODSB",   NO_OPERANDS,                  0,   {CON(0xAC), 0, 0, 0}},                  // Load Byte from [DS:ESI] into AL; Inc ESI
{"LODSW",   NO_OPERANDS,                  O16, {CON(0xAD), 0, 0, 0}},                  // Load Word from [DS:ESI] into AX; Inc ESI
{"LODSD",   NO_OPERANDS,                  O32, {CON(0xAD), 0, 0, 0}},                  // Load Dword from [DS:ESI] into EAX; Inc ESI

// TODO: Add A16 prefixes and syntax for using CX as the LOOP counter?
{"LOOP",    {REL8,   NOT_USED, NOT_USED}, A32, {CON(0xE2), CB, 0, 0}},                 // Decrement ECX, JMP to REL8 if not zero
{"LOOPE",   {REL8,   NOT_USED, NOT_USED}, A32, {CON(0xE1), CB, 0, 0}},                 // Decrement ECX, JMP to REL8 if not zero and ZF = 1
{"LOOPNE",  {REL8,   NOT_USED, NOT_USED}, A32, {CON(0xE0), CB, 0, 0}},                 // Decrement ECX, JMP to REL8 if not zero and ZF = 0

{"LSL",     {R16,    RM16,     NOT_USED}, O16, {CON(0x0F), CON(0x03), MOD_RM, 0}},     // Load Segment limit for selector in RM16
{"LSL",     {R32,    RM32,     NOT_USED}, O32, {CON(0x0F), CON(0x03), MOD_RM, 0}},     // Load Segment limit for selector in RM32

{"LTR",     {RM16,   NOT_USED, NOT_USED},  0,   {CON(0x0F), CON(0x00), OPCODE_EX(3), 0}},  // Load Task Register

{"MOV",     {RM8,     R8,      NOT_USED}, 0,    {CON(0x88), MOD_RM, 0, 0}},             // Load RM8 with value in R8
{"MOV",     {RM16,    R16,     NOT_USED}, O16,  {CON(0x89), MOD_RM, 0, 0}},             // Load RM16 with value in R16
{"MOV",     {RM32,    R32,     NOT_USED}, O32,  {CON(0x89), MOD_RM, 0, 0}},             // Load RM32 with value in R32
{"MOV",     {R8,      RM8,     NOT_USED}, 0,    {CON(0x8A), MOD_RM, 0, 0}},             // Load R8 with value in RM8
{"MOV",     {R16,     RM16,    NOT_USED}, O16,  {CON(0x8B), MOD_RM, 0, 0}},             // Load R16 with value in RM16
{"MOV",     {R32,     RM32,    NOT_USED}, O32,  {CON(0x8B), MOD_RM, 0, 0}},             // Load R32 with value in RM32 
// Unlike NASM, we don't recogise the 16-bit versions of the segment-register MOV instructions; 
{"MOV",     {SEG_REG, RM32,    NOT_USED}, O32,  {CON(0x8E), MOD_RM, 0, 0}},             // Load SEG_REG with segment selector in RM32 low-word
{"MOV",     {RM32,    SEG_REG, NOT_USED}, O32,  {CON(0x8C), MOD_RM, 0, 0}},             // Load RM32 low-word with SEG_REG segment selector
// Ignoring the Memory Offset MOV commands from the 8086. 
{"MOV",     {R8,      IMM8,    NOT_USED}, 0,    {REG_B(0xB0), IB, 0, 0}},               // Load R8 with IMM8
{"MOV",     {R16,     IMM16,   NOT_USED}, O16,  {REG_W(0xB8), IW, 0, 0}},               // Load R16 with IMM16
{"MOV",     {R32,     IMM32,   NOT_USED}, O32,  {REG_W(0xB8), ID, 0, 0}},               // Load R32 with IMM32
{"MOV",     {RM8,     IMM8,    NOT_USED}, 0,    {CON(0xC6), OPCODE_EX(0), IB, 0}},      // Load RM8 with IMM8
{"MOV",     {RM16,    IMM16,   NOT_USED}, O16,  {CON(0xC7), OPCODE_EX(0), IW, 0}},      // Load RM16 with IMM16
{"MOV",     {RM32,    IMM32,   NOT_USED}, O32,  {CON(0xC7), OPCODE_EX(0), ID, 0}},      // Load RM32 with IMM32
// Ignoring the MOV instructions for accessing the control & debug registers

{"MOVSB",   NO_OPERANDS,                  0,    {CON(0xA4), 0, 0, 0}},                  // Copy byte at DS:(E)SI to ES:(E)DI
{"MOVSW",   NO_OPERANDS,                  O16,  {CON(0xA5), 0, 0, 0}},                  // Copy word at DS:(E)SI to ES:(E)DI
{"MOVSD",   NO_OPERANDS,                  O32,  {CON(0xA5), 0, 0, 0}},                  // Copy dword at DS:(E)SI to ES:(E)DI

{"MOVSX",   {R16,     RM8,     NOT_USED}, O16,  {CON(0x0F), CON(0xBE), MOD_RM, 0}},     // Load R16 with RM8, with sign extend
{"MOVSX",   {R32,     RM8,     NOT_USED}, O32,  {CON(0x0F), CON(0xBE), MOD_RM, 0}},     // Load R32 with RM8, with sign extend
{"MOVSX",   {R32,     RM16,    NOT_USED}, O32,  {CON(0x0F), CON(0xBF), MOD_RM, 0}},     // Load R32 with RM16, with sign extend

{"MOVZX",   {R16,     RM8,     NOT_USED}, O16,  {CON(0x0F), CON(0xB6), MOD_RM, 0}},     // Load R16 with RM8, with zero extend
{"MOVZX",   {R32,     RM8,     NOT_USED}, O32,  {CON(0x0F), CON(0xB6), MOD_RM, 0}},     // Load R32 with RM8, with zero extend
{"MOVZX",   {R32,     RM16,    NOT_USED}, O32,  {CON(0x0F), CON(0xB7), MOD_RM, 0}},     // Load R32 with RM16, with zero extend

{"MUL",     {RM8,     NOT_USED,NOT_USED}, 0,    {CON(0xF6), OPCODE_EX(4), 0, 0}},       // Unsigned Multiply AL by RM8, store in AX
{"MUL",     {RM16,    NOT_USED,NOT_USED}, O16,  {CON(0xF7), OPCODE_EX(4), 0, 0}},       // Unsigned Multiply AX by RM16, store in DX:AX
{"MUL",     {RM32,    NOT_USED,NOT_USED}, O32,  {CON(0xF7), OPCODE_EX(4), 0, 0}},       // Unsigned Multiply EAX by RM32, store in EDX:EAX

{"NEG",     {RM8,     NOT_USED,NOT_USED}, 0,    {CON(0xF6), OPCODE_EX(3), 0, 0}},       // Negate RM8
{"NEG",     {RM16,    NOT_USED,NOT_USED}, O16,  {CON(0xF7), OPCODE_EX(3), 0, 0}},       // Negate RM16 
{"NEG",     {RM32,    NOT_USED,NOT_USED}, 032,  {CON(0xF7), OPCODE_EX(3), 0, 0}},       // Negate RM32

{"NOP",     NO_OPERANDS,                  0,    {CON(0x90), 0, 0, 0}},                  // No operation

{"NEG",     {RM8,     NOT_USED,NOT_USED}, 0,    {CON(0xF6), OPCODE_EX(3), 0, 0}},       // Reverse each bit of RM8
{"NEG",     {RM16,    NOT_USED,NOT_USED}, O16,  {CON(0xF7), OPCODE_EX(3), 0, 0}},       // Reverse each bit of RM16 
{"NEG",     {RM32,    NOT_USED,NOT_USED}, O32,  {CON(0xF7), OPCODE_EX(3), 0, 0}},       // Reverse each bit of RM32

{"OR",      {AL,       IMM8,    NOT_USED}, 0,    {CON(0x0C), IB, 0, 0}},                 // Bitwise OR AL with IMM8, result in AL 
{"OR",      {AX,       IMM16,   NOT_USED}, O16,  {CON(0x0D), IW, 0, 0}},                 // Bitwise OR AX with IMM16, result in AX 
{"OR",      {EAX,      IMM32,   NOT_USED}, O32,  {CON(0x0D), ID, 0, 0}},                 // Bitwise OR EAX with IMM32, result in EAX
{"OR",      {RM8,      IMM8,    NOT_USED}, 0,    {CON(0x80), OPCODE_EX(1), IB, 0}},      // Bitwise OR RM8 with IMM8, result in RM8  
{"OR",      {RM16,     IMM16,   NOT_USED}, O16,  {CON(0x81), OPCODE_EX(1), IW, 0}},      // Bitwise OR RM16 with IMM16, result in RM16  
{"OR",      {RM32,     IMM32,   NOT_USED}, O32,  {CON(0x81), OPCODE_EX(1), ID, 0}},      // Bitwise OR RM32 with IMM32, result in RM32
{"OR",      {RM16,     IMM8,    NOT_USED}, O16,  {CON(0x83), OPCODE_EX(1), IB, 0}},      // Bitwise OR RM16 with IMM8 (sign-extended), result in RM16  
{"OR",      {RM32,     IMM8,    NOT_USED}, O32,  {CON(0x83), OPCODE_EX(1), IB, 0}},      // Bitwise OR RM32 with IMM8 (sign-extended), result in RM32
{"OR",      {RM8,      R8,      NOT_USED}, 0,    {CON(0x08), MOD_RM, 0, 0}},             // Bitwise OR RM8 with R8, result in RM8  
{"OR",      {RM16,     R16,     NOT_USED}, O16,  {CON(0x09), MOD_RM, 0, 0}},             // Bitwise OR RM16 with R16, result in RM16  
{"OR",      {RM32,     R32,     NOT_USED}, O32,  {CON(0x09), MOD_RM, 0, 0}},             // Bitwise OR RM32 with R32, result in RM32  
{"OR",      {R8,       RM8,     NOT_USED}, 0,    {CON(0x0A), MOD_RM, 0, 0}},             // Bitwise OR R8 with RM8, result in R8  
{"OR",      {R16,      RM16,    NOT_USED}, O16,  {CON(0x0B), MOD_RM, 0, 0}},             // Bitwise OR R16 with RM16, result in R16  
{"OR",      {R32,      RM32,    NOT_USED}, O32,  {CON(0x0B), MOD_RM, 0, 0}},             // Bitwise OR R32 with RM32, result in R32

{"OUT",     {DX,       AL,      NOT_USED}, 0,    {CON(0xEE), 0, 0, 0}},                  // Copies the value in AL to IO port DX
{"OUT",     {DX,       AX,      NOT_USED}, O16,  {CON(0xEF), 0, 0, 0}},                  // Copies the value in AX to IO port DX
{"OUT",     {DX,       EAX,     NOT_USED}, O32,  {CON(0xEF), 0, 0, 0}},                  // Copies the value in EAX to IO port DX
{"OUT",     {IMM8,     AL,      NOT_USED}, 0,    {CON(0xE6), IB, 0, 0}},                 // Copies the value in AL to IO port IMM8
{"OUT",     {IMM8,     AX,      NOT_USED}, O16,  {CON(0xE7), IB, 0, 0}},                 // Copies the value in AX to IO port IMM8
{"OUT",     {IMM8,     EAX,     NOT_USED}, O32,  {CON(0xE7), IB, 0, 0}},                 // Copies the value in EAX to IO port IMM8  

{"OUTSB",   NO_OPERANDS,                  0,    {CON(0x6E), 0, 0, 0}},                  // Copy byte at DS:(E)SI to IO port DX
{"OUTSW",   NO_OPERANDS,                  O16,  {CON(0x6F), 0, 0, 0}},                  // Copy word at DS:(E)SI to IO port DX
{"OUTSD",   NO_OPERANDS,                  O32,  {CON(0x6F), 0, 0, 0}},                  // Copy dword at DS:(E)SI to IO port DX

{"POP",     {RM16,    NOT_USED, NOT_USED}, O16,  {CON(0x8F), OPCODE_EX(0), 0, 0}},       // Pop top of stack into RM16, increment stack pointer
{"POP",     {RM32,    NOT_USED, NOT_USED}, O32,  {CON(0x8F), OPCODE_EX(0), 0, 0}},       // Pop top of stack into RM32, increment stack pointer
{"POP",     {R16,     NOT_USED, NOT_USED}, O16,  {REG_W(0x58), 0, 0, 0}},                // Pop top of stack into R16, increment stack pointer
{"POP",     {R32,     NOT_USED, NOT_USED}, O32,  {REG_D(0x58), 0, 0, 0}},                // Pop top of stack into R32, increment stack pointer
{"POP",     {DS,      NOT_USED, NOT_USED}, 0,    {CON(0x1F), 0, 0, 0}},                  // Pop 4 bytes off stack, put lower 2 bytes in DS
{"POP",     {ES,      NOT_USED, NOT_USED}, 0,    {CON(0x07), 0, 0, 0}},                  // Pop 4 bytes off stack, put lower 2 bytes in ES
{"POP",     {FS,      NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0xA1), 0, 0}},          // Pop 4 bytes off stack, put lower 2 bytes in FS
{"POP",     {GS,      NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0xA9), 0, 0}},          // Pop 4 bytes off stack, put lower 2 bytes in GS
{"POP",     {SS,      NOT_USED, NOT_USED}, 0,    {CON(0x17), 0, 0, 0}},                  // Pop 4 bytes off stack, put lower 2 bytes in SS

{"POPA",    NO_OPERANDS,                  O16,  {CON(0x61), 0, 0, 0}},                  // Pop DI, SI, BP, BX, DX, CX and AX from the stack
{"POPAD",   NO_OPERANDS,                  O32,  {CON(0x61), 0, 0, 0}},                  // Pop EDI, ESI, EBP, EBX, EDX, ECX and EAX from the stack

{"POPF",    NO_OPERANDS,                  O16,  {CON(0x9D), 0, 0, 0}},                  // Pop Flags register from the stack
{"POPFD",   NO_OPERANDS,                  O32,  {CON(0x9D), 0, 0, 0}},                  // Pop E-Flags register from the stack

{"PUSH",    {RM16,    NOT_USED, NOT_USED}, O16,  {CON(0xFF), OPCODE_EX(6), 0, 0}},       // Push RM16 onto stack, decrement stack pointer
{"PUSH",    {RM32,    NOT_USED, NOT_USED}, O32,  {CON(0xFF), OPCODE_EX(6), 0, 0}},       // Push RM32 onto stack, decrement stack pointer
{"PUSH",    {R16,     NOT_USED, NOT_USED}, O16,  {REG_W(0x50), 0, 0, 0}},                // Push R16 onto stack, decrement stack pointer
{"PUSH",    {R32,     NOT_USED, NOT_USED}, O32,  {REG_D(0x50), 0, 0, 0}},                // Push R32 onto stack, decrement stack pointer
{"PUSH",    {IMM8,    NOT_USED, NOT_USED}, 0,    {CON(0x6A), IB, 0, 0}},                 // Push IMM8 onto stack, decrement stack pointer (by 32-bits)
{"PUSH",    {IMM16,   NOT_USED, NOT_USED}, O16,  {CON(0x68), IW, 0, 0}},                 // Push IMM16 onto stack, decrement stack pointer (by 32-bits)
{"PUSH",    {IMM32,   NOT_USED, NOT_USED}, O32,  {CON(0x68), ID, 0, 0}},                 // Push IMM32 onto stack, decrement stack pointer (by 32-bits)
{"PUSH",    {CS,      NOT_USED, NOT_USED}, 0,    {CON(0x0E), 0, 0, 0}},                  // Push CS bytes onto stack, decrement stack pointer by 4
{"PUSH",    {DS,      NOT_USED, NOT_USED}, 0,    {CON(0x16), 0, 0, 0}},                  // Push DS bytes onto stack, decrement stack pointer by 4
{"PUSH",    {ES,      NOT_USED, NOT_USED}, 0,    {CON(0x06), 0, 0, 0}},                  // Push ES bytes onto stack, decrement stack pointer by 4
{"PUSH",    {FS,      NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0xA0), 0, 0}},          // Push FS bytes onto stack, decrement stack pointer by 4
{"PUSH",    {GS,      NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0xA8), 0, 0}},          // Push GS bytes onto stack, decrement stack pointer by 4
{"PUSH",    {SS,      NOT_USED, NOT_USED}, 0,    {CON(0x16), 0, 0, 0}},                  // Push SS bytes onto stack, decrement stack pointer by 4

{"PUSHA",   NO_OPERANDS,                  O16,  {CON(0x60), 0, 0, 0}},                  // Push AX, CX, DX, BX, original SP, BP, SI and DI onto the stack
{"PUSHAD",  NO_OPERANDS,                  O32,  {CON(0x60), 0, 0, 0}},                  // Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI and EDI onto the stack

{"PUSHF",   NO_OPERANDS,                  O16,  {CON(0x9C), 0, 0, 0}},                  // Push Flags register onto the stack
{"PUSHFD",  NO_OPERANDS,                  O32,  {CON(0x9C), 0, 0, 0}},                  // Push E-Flags register onto the stack

{"RCL",     {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0xD0), OPCODE_EX(2), 0, 0}},       // Rotate RM8 Left by 1-bit, with carry
{"RCL",     {RM16,    NOT_USED, NOT_USED}, O16,  {CON(0xD1), OPCODE_EX(2), 0, 0}},       // Rotate RM16 Left by 1-bit, with carry
{"RCL",     {RM32,    NOT_USED, NOT_USED}, O32,  {CON(0xD1), OPCODE_EX(2), 0, 0}},       // Rotate RM32 Left by 1-bit, with carry
{"RCL",     {RM8,     CL,       NOT_USED}, 0,    {CON(0xD2), OPCODE_EX(2), 0, 0}},       // Rotate RM8 Left by CL bits, with carry
{"RCL",     {RM16,    CL,       NOT_USED}, O16,  {CON(0xD3), OPCODE_EX(2), 0, 0}},       // Rotate RM16 Left by CL bits, with carry
{"RCL",     {RM32,    CL,       NOT_USED}, O32,  {CON(0xD3), OPCODE_EX(2), 0, 0}},       // Rotate RM32 Left by CL bits, with carry
{"RCL",     {RM8,     IMM8,     NOT_USED}, 0,    {CON(0xC0), OPCODE_EX(2), 0, 0}},       // Rotate RM8 Left by IMM8 bits, with carry
{"RCL",     {RM16,    IMM8,     NOT_USED}, O16,  {CON(0xC1), OPCODE_EX(2), 0, 0}},       // Rotate RM16 Left by IMM8 bits, with carry
{"RCL",     {RM32,    IMM8,     NOT_USED}, O32,  {CON(0xC1), OPCODE_EX(2), 0, 0}},       // Rotate RM32 Left by IMM8 bits with carry

{"RCR",     {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0xD0), OPCODE_EX(3), 0, 0}},       // Rotate RM8 right by 1-bit, with carry
{"RCR",     {RM16,    NOT_USED, NOT_USED}, O16,  {CON(0xD1), OPCODE_EX(3), 0, 0}},       // Rotate RM16 right by 1-bit, with carry
{"RCR",     {RM32,    NOT_USED, NOT_USED}, O32,  {CON(0xD1), OPCODE_EX(3), 0, 0}},       // Rotate RM32 right by 1-bit, with carry
{"RCR",     {RM8,     CL,       NOT_USED}, 0,    {CON(0xD2), OPCODE_EX(3), 0, 0}},       // Rotate RM8 right by CL bits, with carry
{"RCR",     {RM16,    CL,       NOT_USED}, O16,  {CON(0xD3), OPCODE_EX(3), 0, 0}},       // Rotate RM16 right by CL bits, with carry
{"RCR",     {RM32,    CL,       NOT_USED}, O32,  {CON(0xD3), OPCODE_EX(3), 0, 0}},       // Rotate RM32 right by CL bits, with carry
{"RCR",     {RM8,     IMM8,     NOT_USED}, 0,    {CON(0xC0), OPCODE_EX(3), 0, 0}},       // Rotate RM8 right by IMM8 bits, with carry
{"RCR",     {RM16,    IMM8,     NOT_USED}, O16,  {CON(0xC1), OPCODE_EX(3), 0, 0}},       // Rotate RM16 right by IMM8 bits, with carry
{"RCR",     {RM32,    IMM8,     NOT_USED}, O32,  {CON(0xC1), OPCODE_EX(3), 0, 0}},       // Rotate RM32 right by IMM8 bits with carry

{"REP",     NO_OPERANDS,                  0,    {CON(0xF3), 0, 0, 0}},                  // Repeat next instruction (E)CX times
{"REPE",    NO_OPERANDS,                  0,    {CON(0xF3), 0, 0, 0}},                  // Repeat next instruction (E)CX times or until ZF=0 (SCAS, CMPS only)
{"REPNE",   NO_OPERANDS,                  0,    {CON(0xF2), 0, 0, 0}},                  // Repeat next instruction (E)CX times or until ZF=1 (SCAS, CMPS only)

{"RET",     NO_OPERANDS,                  0,    {CON(0xC3), 0, 0, 0}},                  // Near Return from procedure
{"RET",     {IMM16,  NOT_USED, NOT_USED}, 0,    {CON(0xC2), IW, 0, 0}},                  // Near Return from procedure		    
{"RETF",    NO_OPERANDS,                  0,    {CON(0xCB), 0, 0, 0}},                  // Far Return from procedure, pop IMM16 bytes from stack
{"RETF",    {IMM16,  NOT_USED, NOT_USED}, 0,    {CON(0xCA), IW, 0, 0}},                  // Near Return from procedure, pop IMM16 bytes from stack

{"ROL",     {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0xD0), OPCODE_EX(0), 0, 0}},       // Rotate RM8 Left by 1-bit
{"ROL",     {RM16,    NOT_USED, NOT_USED}, O16,  {CON(0xD1), OPCODE_EX(0), 0, 0}},       // Rotate RM16 Left by 1-bit
{"ROL",     {RM32,    NOT_USED, NOT_USED}, O32,  {CON(0xD1), OPCODE_EX(0), 0, 0}},       // Rotate RM32 Left by 1-bit
{"ROL",     {RM8,     CL,       NOT_USED}, 0,    {CON(0xD2), OPCODE_EX(0), 0, 0}},       // Rotate RM8 Left by CL bits
{"ROL",     {RM16,    CL,       NOT_USED}, O16,  {CON(0xD3), OPCODE_EX(0), 0, 0}},       // Rotate RM16 Left by CL bits
{"ROL",     {RM32,    CL,       NOT_USED}, O32,  {CON(0xD3), OPCODE_EX(0), 0, 0}},       // Rotate RM32 Left by CL bits
{"ROL",     {RM8,     IMM8,     NOT_USED}, 0,    {CON(0xC0), OPCODE_EX(0), 0, 0}},       // Rotate RM8 Left by IMM8 bits
{"ROL",     {RM16,    IMM8,     NOT_USED}, O16,  {CON(0xC1), OPCODE_EX(0), 0, 0}},       // Rotate RM16 Left by IMM8 bits
{"ROL",     {RM32,    IMM8,     NOT_USED}, O32,  {CON(0xC1), OPCODE_EX(0), 0, 0}},       // Rotate RM32 Left by IMM8 bits

{"ROR",     {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0xD0), OPCODE_EX(1), 0, 0}},       // Rotate RM8 right by 1-bit
{"ROR",     {RM16,    NOT_USED, NOT_USED}, O16,  {CON(0xD1), OPCODE_EX(1), 0, 0}},       // Rotate RM16 right by 1-bit
{"ROR",     {RM32,    NOT_USED, NOT_USED}, O32,  {CON(0xD1), OPCODE_EX(1), 0, 0}},       // Rotate RM32 right by 1-bit
{"ROR",     {RM8,     CL,       NOT_USED}, 0,    {CON(0xD2), OPCODE_EX(1), 0, 0}},       // Rotate RM8 right by CL bits
{"ROR",     {RM16,    CL,       NOT_USED}, O16,  {CON(0xD3), OPCODE_EX(1), 0, 0}},       // Rotate RM16 right by CL bits
{"ROR",     {RM32,    CL,       NOT_USED}, O32,  {CON(0xD3), OPCODE_EX(1), 0, 0}},       // Rotate RM32 right by CL bits
{"ROR",     {RM8,     IMM8,     NOT_USED}, 0,    {CON(0xC0), OPCODE_EX(1), 0, 0}},       // Rotate RM8 right by IMM8 bits
{"ROR",     {RM16,    IMM8,     NOT_USED}, O16,  {CON(0xC1), OPCODE_EX(1), 0, 0}},       // Rotate RM16 right by IMM8 bits
{"ROR",     {RM32,    IMM8,     NOT_USED}, O32,  {CON(0xC1), OPCODE_EX(1), 0, 0}},       // Rotate RM32 right by IMM8 bits

{"SAHF",    NO_OPERANDS,                  0,    {CON(0x9E), 0, 0, 0}},                  // Store AH into Flags

{"SAL",     {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0xD0), OPCODE_EX(4), 0, 0}},       // Shift RM8 Left by 1-bit
{"SAL",     {RM16,    NOT_USED, NOT_USED}, O16,  {CON(0xD1), OPCODE_EX(4), 0, 0}},       // Shift RM16 Left by 1-bit
{"SAL",     {RM32,    NOT_USED, NOT_USED}, O32,  {CON(0xD1), OPCODE_EX(4), 0, 0}},       // Shift RM32 Left by 1-bit
{"SAL",     {RM8,     CL,       NOT_USED}, 0,    {CON(0xD2), OPCODE_EX(4), 0, 0}},       // Shift RM8 Left by CL bits
{"SAL",     {RM16,    CL,       NOT_USED}, O16,  {CON(0xD3), OPCODE_EX(4), 0, 0}},       // Shift RM16 Left by CL bits
{"SAL",     {RM32,    CL,       NOT_USED}, O32,  {CON(0xD3), OPCODE_EX(4), 0, 0}},       // Shift RM32 Left by CL bits
{"SAL",     {RM8,     IMM8,     NOT_USED}, 0,    {CON(0xC0), OPCODE_EX(4), 0, 0}},       // Shift RM8 Left by IMM8 bits
{"SAL",     {RM16,    IMM8,     NOT_USED}, O16,  {CON(0xC1), OPCODE_EX(4), 0, 0}},       // Shift RM16 Left by IMM8 bits
{"SAL",     {RM32,    IMM8,     NOT_USED}, O32,  {CON(0xC1), OPCODE_EX(4), 0, 0}},       // Shift RM32 Left by IMM8 bits

{"SAR",     {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0xD0), OPCODE_EX(7), 0, 0}},       // Shift RM8 right by 1-bit, extend MSB
{"SAR",     {RM16,    NOT_USED, NOT_USED}, O16,  {CON(0xD1), OPCODE_EX(7), 0, 0}},       // Shift RM16 right by 1-bit, extend MSB
{"SAR",     {RM32,    NOT_USED, NOT_USED}, O32,  {CON(0xD1), OPCODE_EX(7), 0, 0}},       // Shift RM32 right by 1-bit, extend MSB
{"SAR",     {RM8,     CL,       NOT_USED}, 0,    {CON(0xD2), OPCODE_EX(7), 0, 0}},       // Shift RM8 right by CL bits, extend MSB
{"SAR",     {RM16,    CL,       NOT_USED}, O16,  {CON(0xD3), OPCODE_EX(7), 0, 0}},       // Shift RM16 right by CL bits, extend MSB
{"SAR",     {RM32,    CL,       NOT_USED}, O32,  {CON(0xD3), OPCODE_EX(7), 0, 0}},       // Shift RM32 right by CL bits, extend MSB
{"SAR",     {RM8,     IMM8,     NOT_USED}, 0,    {CON(0xC0), OPCODE_EX(7), 0, 0}},       // Shift RM8 right by IMM8 bits, extend MSB
{"SAR",     {RM16,    IMM8,     NOT_USED}, O16,  {CON(0xC1), OPCODE_EX(7), 0, 0}},       // Shift RM16 right by IMM8 bits, extend MSB
{"SAR",     {RM32,    IMM8,     NOT_USED}, O32,  {CON(0xC1), OPCODE_EX(7), 0, 0}},       // Shift RM32 right by IMM8 bits, extend MSB

{"SBB",     {AL,      IMM8,     NOT_USED}, 0,    {CON(0x1C), IB, 0, 0}},                 // Subtract IMM8 from AL, with borrow
{"SBB",     {AX,      IMM16,    NOT_USED}, O16,  {CON(0x1D), IB, 0, 0}},                 // Subtract IMM16 from AX, with borrow
{"SBB",     {AL,      IMM32,    NOT_USED}, O32,  {CON(0x1D), IB, 0, 0}},                 // Subtract IMM32 from EAX, with borrow
{"SBB",     {RM8,     IMM8,     NOT_USED}, 0,    {CON(0x80), OPCODE_EX(3), IB, 0}},      // Subtract IMM8 from RM8, with borrow
{"SBB",     {RM16,    IMM16,    NOT_USED}, 0,    {CON(0x81), OPCODE_EX(3), IW, 0}},      // Subtract IMM16 from RM16, with borrow
{"SBB",     {RM32,    IMM32,    NOT_USED}, 0,    {CON(0x81), OPCODE_EX(3), ID, 0}},      // Subtract IMM32 from RM32, with borrow
{"SBB",     {RM16,    IMM8,     NOT_USED}, 0,    {CON(0x83), OPCODE_EX(3), IB, 0}},      // Subtract IMM32 from RM32, with borrow
{"SBB",     {RM32,    IMM8,     NOT_USED}, 0,    {CON(0x83), OPCODE_EX(3), IB, 0}},      // Subtract IMM32 from RM32, with borrow
{"SBB",     {RM8,     R8,       NOT_USED}, 0,    {CON(0x18), MOD_RM, 0, 0}},             // Subtract R8 from RM8, with borrow
{"SBB",     {RM16,    R16,      NOT_USED}, O16,  {CON(0x19), MOD_RM, 0, 0}},             // Subtract R16 from RM16, with borrow
{"SBB",     {RM32,    R32,      NOT_USED}, O32,  {CON(0x19), MOD_RM, 0, 0}},             // Subtract R32 from RM32, with borrow
{"SBB",     {R8,      RM8,      NOT_USED}, 0,    {CON(0x1A), MOD_RM, 0, 0}},             // Subtract RM8 from R8, with borrow
{"SBB",     {R16,     RM16,     NOT_USED}, O16,  {CON(0x1B), MOD_RM, 0, 0}},             // Subtract RM16 from R16, with borrow
{"SBB",     {R32,     RM32,     NOT_USED}, O32,  {CON(0x1B), MOD_RM, 0, 0}},             // Subtract RM32 from R32, with borrow

{"SCASB",   NO_OPERANDS,                  0,    {CON(0xAE), 0, 0, 0}},                  // Compare AL with byte at ES:(E)DI, set flags
{"SCASW",   NO_OPERANDS,                  O16,  {CON(0xAF), 0, 0, 0}},                  // Compare AL with word at ES:(E)DI, set flags
{"SCASD",   NO_OPERANDS,                  O32,  {CON(0xAF), 0, 0, 0}},                  // Compare AL with dword at ES:(E)DI, set flags

// NASM docs say OPCODE_EX(2), Intel Documentation says OPCODE_EX(0)....?
{"SETA",    {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x97), OPCODE_EX(0), 0}}, // Set RM8 if above
{"SETAE",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x93), OPCODE_EX(0), 0}}, // Set RM8 if above or equal
{"SETB",    {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x92), OPCODE_EX(0), 0}}, // Set RM8 if below
{"SETBE",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x96), OPCODE_EX(0), 0}}, // Set RM8 if below or equal
{"SETC",    {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x92), OPCODE_EX(0), 0}}, // Set RM8 if carry
{"SETE",    {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x94), OPCODE_EX(0), 0}}, // Set RM8 if equal
{"SETG",    {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x9F), OPCODE_EX(0), 0}}, // Set RM8 if greater
{"SETGE",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x9D), OPCODE_EX(0), 0}}, // Set RM8 if greater or equal
{"SETL",    {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x9C), OPCODE_EX(0), 0}}, // Set RM8 if less
{"SETLE",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x9E), OPCODE_EX(0), 0}}, // Set RM8 if less or equal
{"SETNA",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x96), OPCODE_EX(0), 0}}, // Set RM8 if not above
{"SETNAE",  {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x92), OPCODE_EX(0), 0}}, // Set RM8 if not above or equal
{"SETNB",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x93), OPCODE_EX(0), 0}}, // Set RM8 if not below
{"SETNBE",  {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x97), OPCODE_EX(0), 0}}, // Set RM8 if not below or equal
{"SETNB",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x93), OPCODE_EX(0), 0}}, // Set RM8 if not carry
{"SETNE",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x95), OPCODE_EX(0), 0}}, // Set RM8 if not equal
{"SETNG",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x9E), OPCODE_EX(0), 0}}, // Set RM8 if not greater
{"SETNGE",  {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x9C), OPCODE_EX(0), 0}}, // Set RM8 if not greater or equal
{"SETNL",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x9D), OPCODE_EX(0), 0}}, // Set RM8 if not less
{"SETNLE",  {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x9F), OPCODE_EX(0), 0}}, // Set RM8 if not less or equal
{"SETNO",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x91), OPCODE_EX(0), 0}}, // Set RM8 if not overflow
{"SETNP",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x9B), OPCODE_EX(0), 0}}, // Set RM8 if not parity
{"SETNS",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x99), OPCODE_EX(0), 0}}, // Set RM8 if not sign
{"SETNZ",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x95), OPCODE_EX(0), 0}}, // Set RM8 if not zero
{"SETO",    {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x90), OPCODE_EX(0), 0}}, // Set RM8 if overflow 
{"SETP",    {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x9A), OPCODE_EX(0), 0}}, // Set RM8 if parity 
{"SETPE",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x9A), OPCODE_EX(0), 0}}, // Set RM8 if parity even 
{"SETPO",   {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x9B), OPCODE_EX(0), 0}}, // Set RM8 if parity odd
{"SETS",    {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x98), OPCODE_EX(0), 0}}, // Set RM8 if sign 
{"SETZ",    {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x94), OPCODE_EX(0), 0}}, // Set RM8 if zero 

{"SGDT",    {M32,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x01), OPCODE_EX(0), 0}}, // Store GDTR in MEM32

{"SHDL",    {RM16,    R16,      IMM8},     O16,  {CON(0x0F), CON(0xA4), MOD_RM, IB}},    // Shift RM16 Left using bits from R16, IMM8 times
{"SHDL",    {RM32,    R32,      IMM8},     O32,  {CON(0x0F), CON(0xA4), MOD_RM, IB}},    // Shift RM32 Left using bits from R32, IMM8 times
{"SHDL",    {RM16,    R16,      CL},       O16,  {CON(0x0F), CON(0xA5), MOD_RM, IB}},    // Shift RM16 Left using bits from R16, CL times
{"SHDL",    {RM32,    R32,      CL},       O32,  {CON(0x0F), CON(0xA5), MOD_RM, IB}},    // Shift RM32 Left using bits from R32, CL times

{"SHDR",    {RM16,    R16,      IMM8},     O16,  {CON(0x0F), CON(0xAC), MOD_RM, IB}},    // Shift RM16 right using bits from R16, IMM8 times
{"SHDR",    {RM32,    R32,      IMM8},     O32,  {CON(0x0F), CON(0xAC), MOD_RM, IB}},    // Shift RM32 right using bits from R32, IMM8 times
{"SHDR",    {RM16,    R16,      CL},       O16,  {CON(0x0F), CON(0xAD), MOD_RM, IB}},    // Shift RM16 right using bits from R16, CL times
{"SHDR",    {RM32,    R32,      CL},       O32,  {CON(0x0F), CON(0xAD), MOD_RM, IB}},    // Shift RM32 right using bits from R32, CL times

{"SIDT",    {M32,     NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x01), OPCODE_EX(1), 0}},  // Store IDTR in M32
{"SLDT",    {RM16,    NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x00), OPCODE_EX(0), 0}},  // Store segment selector from LDT in RM16

{"SHL",     {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0xD0), OPCODE_EX(4), 0, 0}},       // Shift RM8 Left by 1-bit
{"SHL",     {RM16,    NOT_USED, NOT_USED}, O16,  {CON(0xD1), OPCODE_EX(4), 0, 0}},       // Shift RM16 Left by 1-bit
{"SHL",     {RM32,    NOT_USED, NOT_USED}, O32,  {CON(0xD1), OPCODE_EX(4), 0, 0}},       // Shift RM32 Left by 1-bit
{"SHL",     {RM8,     CL,       NOT_USED}, 0,    {CON(0xD2), OPCODE_EX(4), 0, 0}},       // Shift RM8 Left by CL bits
{"SHL",     {RM16,    CL,       NOT_USED}, O16,  {CON(0xD3), OPCODE_EX(4), 0, 0}},       // Shift RM16 Left by CL bits
{"SHL",     {RM32,    CL,       NOT_USED}, O32,  {CON(0xD3), OPCODE_EX(4), 0, 0}},       // Shift RM32 Left by CL bits
{"SHL",     {RM8,     IMM8,     NOT_USED}, 0,    {CON(0xC0), OPCODE_EX(4), 0, 0}},       // Shift RM8 Left by IMM8 bits
{"SHL",     {RM16,    IMM8,     NOT_USED}, O16,  {CON(0xC1), OPCODE_EX(4), 0, 0}},       // Shift RM16 Left by IMM8 bits
{"SHL",     {RM32,    IMM8,     NOT_USED}, O32,  {CON(0xC1), OPCODE_EX(4), 0, 0}},       // Shift RM32 Left by IMM8 bits

{"SHR",     {RM8,     NOT_USED, NOT_USED}, 0,    {CON(0xD0), OPCODE_EX(5), 0, 0}},       // Shift RM8 right by 1-bit, MSB=0
{"SHR",     {RM16,    NOT_USED, NOT_USED}, O16,  {CON(0xD1), OPCODE_EX(5), 0, 0}},       // Shift RM16 right by 1-bit, MSB=0
{"SHR",     {RM32,    NOT_USED, NOT_USED}, O32,  {CON(0xD1), OPCODE_EX(5), 0, 0}},       // Shift RM32 right by 1-bit, MSB=0
{"SHR",     {RM8,     CL,       NOT_USED}, 0,    {CON(0xD2), OPCODE_EX(5), 0, 0}},       // Shift RM8 right by CL bits, MSB=0
{"SHR",     {RM16,    CL,       NOT_USED}, O16,  {CON(0xD3), OPCODE_EX(5), 0, 0}},       // Shift RM16 right by CL bits, MSB=0
{"SHR",     {RM32,    CL,       NOT_USED}, O32,  {CON(0xD3), OPCODE_EX(5), 0, 0}},       // Shift RM32 right by CL bits, MSB=0
{"SHR",     {RM8,     IMM8,     NOT_USED}, 0,    {CON(0xC0), OPCODE_EX(5), 0, 0}},       // Shift RM8 right by IMM8 bits, MSB=0
{"SHR",     {RM16,    IMM8,     NOT_USED}, O16,  {CON(0xC1), OPCODE_EX(5), 0, 0}},       // Shift RM16 right by IMM8 bits, MSB=0
{"SHR",     {RM32,    IMM8,     NOT_USED}, O32,  {CON(0xC1), OPCODE_EX(5), 0, 0}},       // Shift RM32 right by IMM8 bits, MSB=0

// Ignore SMSW - 286 only

{"STC",     NO_OPERANDS,                   0,    {CON(0xF9), 0, 0, 0}},                  // Set the Carry Flag
{"STD",     NO_OPERANDS,                   0,    {CON(0xFD), 0, 0, 0}},                  // Set the Direction Flag
{"STI",     NO_OPERANDS,                   0,    {CON(0xFB), 0, 0, 0}},                  // Enable interrupts

{"STOSB",   NO_OPERANDS,                   0,    {CON(0xAA), 0, 0, 0}},                  // Store byte in AL in ES:(E)DI
{"STOSW",   NO_OPERANDS,                   O16,  {CON(0xAB), 0, 0, 0}},                  // Store word in AX in ES:(E)DI
{"STOSD",   NO_OPERANDS,                   O32,  {CON(0xAB), 0, 0, 0}},                  // Store dword in EAX in ES:(E)DI

{"STR",     {RM16,    NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x00), OPCODE_EX(1), 0}}, // Store segment selector from task reg in RM16

{"SUB",     {AL,      IMM8,     NOT_USED}, 0,    {CON(0x2C), IB, 0, 0}},                 // Subtract IMM8 from AL
{"SUB",     {AX,      IMM8,     NOT_USED}, 0,    {CON(0x2D), IW, 0, 0}},                 // Subtract IMM16 from AX
{"SUB",     {EAX,     IMM8,     NOT_USED}, 0,    {CON(0x2D), ID, 0, 0}},                 // Subtract IMM32 from EAX
{"SUB",     {RM8,     IMM8,     NOT_USED}, 0,    {CON(0x80), OPCODE_EX(5), IB, 0}},      // Subtract IMM8 from RM8
{"SUB",     {RM16,    IMM16,    NOT_USED}, O16,  {CON(0x81), OPCODE_EX(5), IW, 0}},      // Subtract IMM16 from RM16
{"SUB",     {RM32,    IMM32,    NOT_USED}, O32,  {CON(0x81), OPCODE_EX(5), ID, 0}},      // Subtract IMM32 from RM32
{"SUB",     {RM16,    IMM8,     NOT_USED}, O16,  {CON(0x83), OPCODE_EX(5), IB, 0}},      // Subtract IMM8 (sign-extended) from RM8
{"SUB",     {RM32,    IMM8,     NOT_USED}, O32,  {CON(0x83), OPCODE_EX(5), IB, 0}},      // Subtract IMM8 (sign-extended) from RM8
{"SUB",     {RM8,     R8,       NOT_USED}, 0,    {CON(0x28), MOD_RM, 0, 0}},            // Subtract R8 from RM8
{"SUB",     {RM16,    R16,      NOT_USED}, O16,  {CON(0x29), MOD_RM, 0, 0}},            // Subtract R16 from RM16
{"SUB",     {RM32,    R32,      NOT_USED}, O32,  {CON(0x29), MOD_RM, 0, 0}},            // Subtract R32 from RM32
{"SUB",     {R8,      RM8,      NOT_USED}, 0,    {CON(0x2A), MOD_RM, 0, 0}},            // Subtract RM8 from R8
{"SUB",     {R16,     RM16,     NOT_USED}, O16,  {CON(0x2B), MOD_RM, 0, 0}},            // Subtract RM16 from R16
{"SUB",     {R32,     RM32,     NOT_USED}, O32,  {CON(0x2B), MOD_RM, 0, 0}},            // Subtract RM32 from R32

{"TEST",    {AL,      IMM8,     NOT_USED}, 0,    {CON(0xA8), IB, 0, 0}},                 // AND IMM8 with AL, set flags 
{"TEST",    {AX,      IMM8,     NOT_USED}, 0,    {CON(0xA9), IW, 0, 0}},                 // AND IMM16 with AX, set flags 
{"TEST",    {EAX,     IMM8,     NOT_USED}, 0,    {CON(0xA9), ID, 0, 0}},                 // AND IMM32 with EAX, set flags 
{"TEST",    {RM8,     IMM8,     NOT_USED}, 0,    {CON(0xF6), OPCODE_EX(0), IB, 0}},      // AND IMM8 with RM8, set flags 
{"TEST",    {RM16,    IMM16,    NOT_USED}, O16,  {CON(0xF7), OPCODE_EX(0), IW, 0}},      // AND IMM16 with RM16, set flags 
{"TEST",    {RM32,    IMM32,    NOT_USED}, O32,  {CON(0xF7), OPCODE_EX(0), ID, 0}},      // AND IMM32 with RM32, set flags 
{"TEST",    {RM8,     R8,       NOT_USED}, 0,    {CON(0x84), MOD_RM, 0, 0}},            // AND R8 with RM8, set flags 
{"TEST",    {RM16,    R16,      NOT_USED}, O16,  {CON(0x85), MOD_RM, 0, 0}},            // AND R16 with RM16, set flags 
{"TEST",    {RM32,    R32,      NOT_USED}, O32,  {CON(0x85), MOD_RM, 0, 0}},            // AND R32 with RM32, set flags 

{"VERR",    {RM16,    NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x00), OPCODE_EX(4), 0}}, // Verify if segment with selector in RM16 can be read
{"VERW",    {RM16,    NOT_USED, NOT_USED}, 0,    {CON(0x0F), CON(0x00), OPCODE_EX(5), 0}}, // Verify if segment with selector in RM16 can be written

{"WAIT",    NO_OPERANDS,                   0,    {CON(0x9B), 0, 0, 0}},                  // Check for pending unmasked floating point exceptions

{"XCHG",    {AX,      R16,      NOT_USED}, O16,  {REG_W(0x90), 0, 0, 0}},                // Exchange AX and R16
{"XCHG",    {R16,     AX,       NOT_USED}, O16,  {REG_W(0x90), 0, 0, 0}},                // Exchange AX and R16
{"XCHG",    {EAX,     R32,      NOT_USED}, O32,  {REG_W(0x90), 0, 0, 0}},                // Exchange EAX and R32
{"XCHG",    {R32,     EAX,      NOT_USED}, O32,  {REG_W(0x90), 0, 0, 0}},                // Exchange EAX and R3
{"XCHG",    {RM8,     R8,       NOT_USED}, 0,    {CON(0x86), MOD_RM, 0, 0}},             // Exchange R8 with RM8
{"XCHG",    {RM16,    R16,      NOT_USED}, O16,  {CON(0x87), MOD_RM, 0, 0}},             // Exchange R16 with RM16
{"XCHG",    {RM32,    R32,      NOT_USED}, O32,  {CON(0x87), MOD_RM, 0, 0}},             // Exchange R32 with RM32
{"XCHG",    {R8,      RM8,      NOT_USED}, 0,    {CON(0x86), MOD_RM, 0, 0}},             // Exchange RM8 with R8
{"XCHG",    {R16,     RM16,     NOT_USED}, O16,  {CON(0x87), MOD_RM, 0, 0}},             // Exchange RM16 with R16
{"XCHG",    {R32,     RM32,     NOT_USED}, O32,  {CON(0x87), MOD_RM, 0, 0}},             // Exchange RM32 with R32

{"XLAT",    NO_OPERANDS,                   0,    {CON(0xD7), 0, 0, 0}},                  // Load AL from DS:[(E)BX + AL(unsigned)]

{"XOR",     {AL,       IMM8,    NOT_USED}, 0,    {CON(0x34), IB, 0, 0}},                  // Bitwise XOR AL with IMM8, result in AL 
{"XOR",     {AX,       IMM16,   NOT_USED}, O16,  {CON(0x35), IW, 0, 0}},                  // Bitwise XOR AX with IMM16, result in AX 
{"XOR",     {EAX,      IMM32,   NOT_USED}, O32,  {CON(0x35), ID, 0, 0}},                  // Bitwise XOR EAX with IMM32, result in EAX
{"XOR",     {RM8,      IMM8,    NOT_USED}, 0,    {CON(0x80), OPCODE_EX(6), IB, 0}},       // Bitwise XOR RM8 with IMM8, result in RM8  
{"XOR",     {RM16,     IMM16,   NOT_USED}, O16,  {CON(0x81), OPCODE_EX(6), IW, 0}},       // Bitwise XOR RM16 with IMM16, result in RM16  
{"XOR",     {RM32,     IMM32,   NOT_USED}, O32,  {CON(0x81), OPCODE_EX(6), ID, 0}},       // Bitwise XOR RM32 with IMM32, result in RM32
{"XOR",     {RM16,     IMM8,    NOT_USED}, O16,  {CON(0x83), OPCODE_EX(6), IB, 0}},       // Bitwise XOR RM16 with IMM8 (sign-extended), result in RM16  
{"XOR",     {RM32,     IMM8,    NOT_USED}, O32,  {CON(0x83), OPCODE_EX(6), IB, 0}},       // Bitwise XOR RM32 with IMM8 (sign-extended), result in RM32
{"XOR",     {RM8,      R8,      NOT_USED}, 0,    {CON(0x30), MOD_RM, 0, 0}},              // Bitwise XOR RM8 with R8, result in RM8  
{"XOR",     {RM16,     R16,     NOT_USED}, O16,  {CON(0x31), MOD_RM, 0, 0}},              // Bitwise XOR RM16 with R16, result in RM16  
{"XOR",     {RM32,     R32,     NOT_USED}, O32,  {CON(0x31), MOD_RM, 0, 0}},              // Bitwise XOR RM32 with R32, result in RM32  
{"XOR",     {R8,       RM8,     NOT_USED}, 0,    {CON(0x32), MOD_RM, 0, 0}},              // Bitwise XOR R8 with RM8, result in R8  
{"XOR",     {R16,      RM16,    NOT_USED}, O16,  {CON(0x33), MOD_RM, 0, 0}},              // Bitwise XOR R16 with RM16, result in R16  
{"XOR",     {R32,      RM32,    NOT_USED}, O32,  {CON(0x33), MOD_RM, 0, 0}}               // Bitwise XOR R32 with RM32, result in R32
};
#endif	/* _INSTRUCTIONS_H */

    

